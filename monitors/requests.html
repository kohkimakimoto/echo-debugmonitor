<div x-data="requestsMonitor({{.UsePolling}})" class="h-full flex flex-col" x-clock>
  <!-- Connection status indicator and controls -->
  <div class="px-4 py-2 bg-white dark:bg-gray-950 border-b dark:border-gray-700 border-gray-200 sticky top-0 left-0">
    <div class="flex items-center justify-start space-x-4">
      <button
        @click="toggleLiveUpdates()"
        class="px-3 py-1 text-xs rounded transition-colors"
        :class="liveUpdatesEnabled ? 'bg-blue-500 hover:bg-blue-600 text-white' : 'bg-gray-300 hover:bg-gray-400 dark:bg-gray-600 dark:hover:bg-gray-500 text-gray-700 dark:text-gray-200'"
      >
        <span x-text="liveUpdatesEnabled ? 'Live Updates ON' : 'Live Updates OFF'"></span>
      </button>
      <div class="flex items-center space-x-2">
        <div :class="connected ? 'bg-green-500' : 'bg-red-500'" class="w-2 h-2 rounded-full"></div>
        <span class="text-xs text-gray-500 dark:text-gray-400" x-text="connected ? 'Connected' : 'Disconnected'"></span>
      </div>
    </div>
  </div>

  <!-- Content area -->
  <div class="flex-1 overflow-y-auto p-4">
    <div class="space-y-2">
      <!-- Display entries in reverse order (newest first) -->
      <template x-for="entry in entries" :key="entry.id">
        <div
          class="bg-gray-50 dark:bg-gray-800 rounded p-4 border border-gray-200 dark:border-gray-700"
          :class="{ 'entry-appear': entry.isNew }"
        >
          <div class="flex items-start justify-between mb-2">
            <div class="flex items-center space-x-3">
              <!-- HTTP Method badge -->
              <span
                class="px-2 py-1 text-xs font-mono font-semibold rounded"
                :class="{
                  'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200': entry.payload.method === 'GET',
                  'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200': entry.payload.method === 'POST',
                  'bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200': entry.payload.method === 'PUT',
                  'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200': entry.payload.method === 'DELETE',
                  'bg-purple-100 text-purple-800 dark:bg-purple-900 dark:text-purple-200': entry.payload.method === 'PATCH',
                  'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-200': !['GET', 'POST', 'PUT', 'DELETE', 'PATCH'].includes(entry.payload.method)
                }"
                x-text="entry.payload.method"
              ></span>

              <!-- Status code badge -->
              <span
                class="px-2 py-1 text-xs font-mono font-semibold rounded"
                :class="{
                  'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200': entry.payload.status >= 200 && entry.payload.status < 300,
                  'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200': entry.payload.status >= 300 && entry.payload.status < 400,
                  'bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200': entry.payload.status >= 400 && entry.payload.status < 500,
                  'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200': entry.payload.status >= 500
                }"
                x-text="entry.payload.status"
              ></span>

              <!-- Latency -->
              <span class="text-xs text-gray-500 dark:text-gray-400">
                <span x-text="entry.payload.latency"></span>ms
              </span>
            </div>

            <!-- Timestamp -->
            <span class="text-xs text-gray-500 dark:text-gray-400" x-text="formatTimestamp(entry.payload.timestamp)"></span>
          </div>

          <!-- URI -->
          <div class="mb-2">
            <code class="text-sm text-gray-900 dark:text-gray-100 font-mono break-all" x-text="entry.payload.uri"></code>
          </div>

          <!-- Additional details -->
          <div class="grid grid-cols-2 gap-2 text-xs">
            <div>
              <span class="text-gray-500 dark:text-gray-400">Remote IP:</span>
              <span class="text-gray-900 dark:text-gray-100 ml-1 font-mono" x-text="entry.payload.remoteAddr"></span>
            </div>
            <template x-if="entry.payload.userAgent">
              <div class="col-span-2">
                <span class="text-gray-500 dark:text-gray-400">User Agent:</span>
                <span class="text-gray-900 dark:text-gray-100 ml-1 font-mono text-xs break-all" x-text="entry.payload.userAgent"></span>
              </div>
            </template>
          </div>

          <!-- Error message if present -->
          <template x-if="entry.payload.error">
            <div class="mt-2 p-2 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded">
              <div class="text-xs text-red-800 dark:text-red-200 font-semibold mb-1">Error:</div>
              <pre class="text-xs text-red-700 dark:text-red-300 whitespace-pre-wrap font-mono" x-text="entry.payload.error"></pre>
            </div>
          </template>

          <!-- Headers if present -->
          <template x-if="entry.payload.headers && Object.keys(entry.payload.headers).length > 0">
            <div class="mt-2">
              <button
                @click="entry._showHeaders = !entry._showHeaders"
                class="text-xs text-blue-600 dark:text-blue-400 hover:underline"
              >
                <span x-text="entry._showHeaders ? 'Hide Request Headers' : 'Show Request Headers'"></span>
              </button>
              <div x-show="entry._showHeaders" class="mt-2 p-2 bg-gray-100 dark:bg-gray-900 rounded">
                <template x-for="(value, key) in entry.payload.headers" :key="key">
                  <div class="text-xs mb-1">
                    <span class="text-gray-600 dark:text-gray-400 font-mono" x-text="key"></span>:
                    <span class="text-gray-900 dark:text-gray-100 font-mono" x-text="value"></span>
                  </div>
                </template>
              </div>
            </div>
          </template>
        </div>
      </template>

      <!-- Empty state -->
      <template x-if="isBooted && entries.length === 0">
        <div class="text-center py-12">
          <svg class="mx-auto h-12 w-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
          </svg>
          <p class="mt-2 text-sm text-gray-500 dark:text-gray-400">No requests yet</p>
        </div>
      </template>
    </div>
  </div>
</div>

<script>
  function requestsMonitor(usePolling) {
    return {
      entries: [],
      lastId: 0,
      connected: false,
      liveUpdatesEnabled: true,
      eventSource: null,
      pollingInterval: null,
      isBooted: false,
      usePolling: usePolling,

      init: function () {
        // Fetch initial data first
        this.fetchInitialData().then(() => {
          // Then start real-time updates
          if (this.usePolling) {
            this.startPolling();
          } else {
            this.connectSSE();
          }
        });
      },

      async fetchInitialData() {
        const params = new URLSearchParams(window.location.search);
        const monitor = params.get('monitor');

        try {
          const response = await fetch(`?monitor=${monitor}&action=data&since=0`);
          if (response.ok) {
            const entries = await response.json();
            // Add entries in reverse order (newest first for display)
            for (let i = entries.length - 1; i >= 0; i--) {
              const entry = entries[i];
              entry._showHeaders = false;
              this.entries.unshift(entry);
              if (entry.id > this.lastId) {
                this.lastId = entry.id;
              }
            }
          }
        } catch (error) {
          console.error('Failed to fetch initial data:', error);
        }

        this.isBooted = true;
      },

      toggleLiveUpdates() {
        this.liveUpdatesEnabled = !this.liveUpdatesEnabled;

        if (this.liveUpdatesEnabled) {
          // Turn live updates ON
          if (this.usePolling) {
            this.startPolling();
          } else {
            this.connectSSE();
          }
        } else {
          // Turn live updates OFF
          if (this.usePolling) {
            this.stopPolling();
          } else {
            this.disconnectSSE();
          }
        }
      },

      startPolling() {
        // Don't start if live updates are disabled
        if (!this.liveUpdatesEnabled) {
          return;
        }

        // Clear existing interval if any
        if (this.pollingInterval) {
          clearInterval(this.pollingInterval);
        }

        this.connected = true;

        const params = new URLSearchParams(window.location.search);
        const monitor = params.get('monitor');

        // Poll every 1 second
        this.pollingInterval = setInterval(async () => {
          try {
            const response = await fetch(`?monitor=${monitor}&action=data&since=${this.lastId}`);
            if (response.ok) {
              const entries = await response.json();
              for (const entry of entries) {
                entry._showHeaders = false;
                // Mark as new for animation
                entry.isNew = true;
                this.entries.unshift(entry);
                if (entry.id > this.lastId) {
                  this.lastId = entry.id;
                }
                // Remove isNew flag after animation completes
                setTimeout(() => {
                  entry.isNew = false;
                }, 350);
              }
            }
          } catch (error) {
            console.error('Polling error:', error);
            this.connected = false;
          }
        }, 1000);
      },

      stopPolling() {
        if (this.pollingInterval) {
          clearInterval(this.pollingInterval);
          this.pollingInterval = null;
          this.connected = false;
        }
      },

      connectSSE() {
        // Don't connect if live updates are disabled
        if (!this.liveUpdatesEnabled) {
          return;
        }

        const params = new URLSearchParams(window.location.search);
        const monitor = params.get('monitor');

        // Close existing connection if any
        if (this.eventSource) {
          this.eventSource.close();
        }

        this.eventSource = new EventSource(`?monitor=${monitor}&action=stream&since=${this.lastId}`);

        this.eventSource.onopen = () => {
          this.connected = true;
        };

        this.eventSource.onerror = (error) => {
          console.error('SSE connection error:', error);
          this.connected = false;

          // Only attempt to reconnect if live updates are still enabled
          if (this.liveUpdatesEnabled) {
            setTimeout(() => {
              this.connectSSE();
            }, 5000);
          }
        };

        this.eventSource.onmessage = (event) => {
          try {
            const entry = JSON.parse(event.data);
            // Initialize _showHeaders for headers toggle
            entry._showHeaders = false;
            // Mark as new for animation
            entry.isNew = true;
            this.entries.unshift(entry);
            // Update last ID
            this.lastId = entry.id;
            // Remove isNew flag after animation completes
            setTimeout(() => {
              entry.isNew = false;
            }, 350);
          } catch (error) {
            console.error('Failed to parse SSE message:', error);
          }
        };
      },

      disconnectSSE() {
        if (this.eventSource) {
          this.eventSource.close();
          this.eventSource = null;
          this.connected = false;
        }
      },

      formatTimestamp(timestamp) {
        const date = new Date(timestamp);
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        const seconds = String(date.getSeconds()).padStart(2, '0');
        const ms = String(date.getMilliseconds()).padStart(3, '0');
        return `${hours}:${minutes}:${seconds}.${ms}`;
      },

      destroy() {
        // Cleanup when component is destroyed
        this.disconnectSSE();
        this.stopPolling();
      }
    }
  }
</script>
