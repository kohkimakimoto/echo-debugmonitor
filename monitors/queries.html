<div x-data="queriesMonitor()" class="h-full flex flex-col" x-clock>
  <!-- Connection status indicator and controls -->
  <div class="px-4 py-2 bg-white dark:bg-gray-950 border-b dark:border-gray-700 border-gray-200 sticky top-0 left-0">
    <div class="flex items-center justify-start space-x-4">
      <button
        @click="toggleLiveUpdates()"
        class="px-3 py-1 text-xs rounded transition-colors"
        :class="liveUpdatesEnabled ? 'bg-blue-500 hover:bg-blue-600 text-white' : 'bg-gray-300 hover:bg-gray-400 dark:bg-gray-600 dark:hover:bg-gray-500 text-gray-700 dark:text-gray-200'"
      >
        <span x-text="liveUpdatesEnabled ? 'Live Updates ON' : 'Live Updates OFF'"></span>
      </button>
      <div class="flex items-center space-x-2">
        <div :class="connected ? 'bg-green-500' : 'bg-red-500'" class="w-2 h-2 rounded-full"></div>
        <span class="text-xs text-gray-500 dark:text-gray-400" x-text="connected ? 'Connected' : 'Disconnected'"></span>
      </div>
    </div>
  </div>

  <!-- Content area -->
  <div class="flex-1 overflow-y-auto p-4">
    <div class="space-y-2">
      <!-- Display entries in reverse order (newest first) -->
      <template x-for="entry in entries" :key="entry.id">
        <div
          class="bg-gray-50 dark:bg-gray-800 rounded p-4 border border-gray-200 dark:border-gray-700"
          :class="{ 'entry-appear': entry.isNew }"
        >
          <div class="flex items-start justify-between mb-2">
            <div class="flex items-center space-x-3">
              <!-- Operation badge -->
              <span
                class="px-2 py-1 text-xs font-mono font-semibold rounded"
                :class="{
                  'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200': entry.payload.operation === 'Query',
                  'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200': entry.payload.operation === 'Exec',
                  'bg-purple-100 text-purple-800 dark:bg-purple-900 dark:text-purple-200': entry.payload.operation === 'Prepare',
                  'bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200': entry.payload.operation === 'Begin',
                  'bg-indigo-100 text-indigo-800 dark:bg-indigo-900 dark:text-indigo-200': entry.payload.operation === 'Commit',
                  'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200': entry.payload.operation === 'Rollback',
                  'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-200': !['Query', 'Exec', 'Prepare', 'Begin', 'Commit', 'Rollback'].includes(entry.payload.operation)
                }"
                x-text="entry.payload.operation"
              ></span>

              <!-- Duration -->
              <span class="text-xs text-gray-500 dark:text-gray-400">
                <span x-text="entry.payload.duration"></span>ms
              </span>
            </div>

            <!-- Timestamp -->
            <span class="text-xs text-gray-500 dark:text-gray-400" x-text="formatTimestamp(entry.payload.timestamp)"></span>
          </div>

          <!-- Query -->
          <div class="mb-2">
            <code class="text-sm text-gray-900 dark:text-gray-100 font-mono break-all whitespace-pre-wrap" x-text="entry.payload.query"></code>
          </div>

          <!-- Arguments if present -->
          <template x-if="entry.payload.args && entry.payload.args.length > 0">
            <div class="mb-2">
              <div class="text-xs text-gray-500 dark:text-gray-400 mb-1">Arguments:</div>
              <div class="flex flex-wrap gap-1">
                <template x-for="(arg, index) in entry.payload.args" :key="index">
                  <span class="px-2 py-1 text-xs bg-gray-100 dark:bg-gray-700 rounded font-mono text-gray-900 dark:text-gray-100">
                    <span class="text-gray-500 dark:text-gray-400" x-text="'$' + (index + 1) + ':'"></span>
                    <span x-text="formatArgument(arg)"></span>
                  </span>
                </template>
              </div>
            </div>
          </template>

          <!-- Error message if present -->
          <template x-if="entry.payload.error">
            <div class="mt-2 p-2 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded">
              <div class="text-xs text-red-800 dark:text-red-200 font-semibold mb-1">Error:</div>
              <pre class="text-xs text-red-700 dark:text-red-300 whitespace-pre-wrap font-mono" x-text="entry.payload.error"></pre>
            </div>
          </template>
        </div>
      </template>

      <!-- Empty state -->
      <template x-if="isBooted && entries.length === 0">
        <div class="text-center py-12">
          <svg class="mx-auto h-12 w-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 7v10c0 2.21 3.582 4 8 4s8-1.79 8-4V7M4 7c0 2.21 3.582 4 8 4s8-1.79 8-4M4 7c0-2.21 3.582-4 8-4s8 1.79 8 4m0 5c0 2.21-3.582 4-8 4s-8-1.79-8-4"></path>
          </svg>
          <p class="mt-2 text-sm text-gray-500 dark:text-gray-400">No queries yet</p>
        </div>
      </template>
    </div>
  </div>

</div>

<script>
  function queriesMonitor() {
    return {
      entries: [],
      lastId: 0,
      connected: false,
      liveUpdatesEnabled: true,
      eventSource: null,
      isBooted: false,

      init: function () {
        this.connectSSE();
      },

      toggleLiveUpdates() {
        this.liveUpdatesEnabled = !this.liveUpdatesEnabled;

        if (this.liveUpdatesEnabled) {
          // Turn live updates ON
          this.connectSSE();
        } else {
          // Turn live updates OFF
          this.disconnectSSE();
        }
      },

      connectSSE() {
        // Don't connect if live updates are disabled
        if (!this.liveUpdatesEnabled) {
          return;
        }

        const params = new URLSearchParams(window.location.search);
        const monitor = params.get('monitor');

        // Close existing connection if any
        if (this.eventSource) {
          this.eventSource.close();
        }

        this.eventSource = new EventSource(`?monitor=${monitor}&action=stream&since=${this.lastId}`);

        this.eventSource.onopen = () => {
          this.connected = true;
          // Mark as booted once connection is established
          this.isBooted = true;
        };

        this.eventSource.onerror = (error) => {
          console.error('SSE connection error:', error);
          this.connected = false;

          // Only attempt to reconnect if live updates are still enabled
          if (this.liveUpdatesEnabled) {
            setTimeout(() => {
              this.connectSSE();
            }, 5000);
          }
        };

        this.eventSource.onmessage = (event) => {
          try {
            const entry = JSON.parse(event.data);
            // Mark as new for animation
            entry.isNew = true;
            this.entries.unshift(entry);
            // Update last ID
            this.lastId = entry.id;
            // Remove isNew flag after animation completes
            setTimeout(() => {
              entry.isNew = false;
            }, 350);
          } catch (error) {
            console.error('Failed to parse SSE message:', error);
          }
        };
      },

      disconnectSSE() {
        if (this.eventSource) {
          this.eventSource.close();
          this.eventSource = null;
          this.connected = false;
        }
      },

      formatTimestamp(timestamp) {
        const date = new Date(timestamp);
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        const seconds = String(date.getSeconds()).padStart(2, '0');
        const ms = String(date.getMilliseconds()).padStart(3, '0');
        return `${hours}:${minutes}:${seconds}.${ms}`;
      },

      formatArgument(arg) {
        if (arg === null) return 'null';
        if (arg === undefined) return 'undefined';
        if (typeof arg === 'string') return `"${arg}"`;
        return String(arg);
      },

      destroy() {
        // Cleanup when component is destroyed
        this.disconnectSSE();
      }
    }
  }
</script>
